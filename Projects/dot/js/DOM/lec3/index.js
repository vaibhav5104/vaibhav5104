// Reflow is a process of calculating the dimension and position of page element.This is a computational intensive task which takes time.
// Repaint is a process of drawing pixels to the screen.Faster than reflow.


// Document Fregment light weight document object.Doesn't take reflow and repaint except when it adds in document.

// Note: Js is single thread language which means it can execute single command at a time


const t1 = performance.now();

for(let i=1; i<=100; i++){
    let newElement = document.createElement('p');
    newElement.textContent = 'This is para' + i;
    document.body.appendChild(newElement);
}

const t2 = performance.now();

console.log("this took" + (t2-t1) + "ms");

// optimising a bit

const t3 = performance.now();

let myDiv = document.createElement('div');

for(let i=1; i<=100; i++){
    let element = document.createElement('p');
    element.textContent = 'This is para' + i;

    myDiv.appendChild(element);
}

document.body.appendChild(myDiv);

const t4 = performance.now();

console.log("this took" + (t4-t3) + "ms");// less time taken because of less reflow and repaint

const t5 = performance.now();

let fragment = document.createDocumentFragment('div');

for(let i=1; i<=100; i++){
    let element = document.createElement('p');
    element.textContent = 'This is para' + i;

    fragment.appendChild(element);
}

document.body.appendChild(fragment);// 1 Reflow , 1 Repaint

const t6 = performance.now();

console.log("this took" + (t6-t5) + "ms");




// concurrency and multithreading in js

/* Call stack : In JavaScript, the call stack is a mechanism that helps the interpreter keep track of its place 
in a script that calls multiple functions. It operates on a Last In, First Out (LIFO) basis. 
When a script calls a function, the interpreter adds it to the top of the call stack. When the function finishes executing, 
the interpreter removes it from the stack and resumes execution where it left off in the calling function. 

ex: function a() {
    console.log('hi');
    b();
}

function b() {
    console.log('Hello');
}

a();

// Let's break down the code and understand what happens in the call stack:

// The script starts executing, and it encounters the a() function call at the end.
// The a() function is pushed onto the call stack.
// Inside a(), the console.log('hi'); statement is executed, printing 'hi' to the console.
// The b() function is called from within a().
// The b() function is pushed onto the call stack.
// Inside b(), the console.log('Hello'); statement is executed, printing 'Hello' to the console.
// The b() function completes its execution and is popped off the call stack.
// Execution returns to the point immediately after the b() call inside the a() function.
// The a() function completes its execution and is popped off the call stack.
// The main script has no more code to execute, and the program terminates.




*/


// Note : Synchronious functiona are functions which executes line by line.They go to call stack and when they are finished 
// they pulled off from call stack.
// ASynchronious functions are functions which do not execute line by line and call stack get them for a moment and then hand over to browser from 
// where it goes to event queue which pullled it off to call stack only when the call stack is empty . this process is event loop.

// event queue : The event queue is where events and messages, including those generated by timers, are stored

/* setTimeOut() :  setTimeout(() => {console.log("this is the first message")}, 5000);

// other example : 

// console.log("Hello");
// setTimeout(() => {console.log("Function")}, 5000);
// console.log("hy");

// In this code console method will go to call stack and when it is used ,it get pulled off from call stack and then setTimeOut funciton goes to 
// call stack but since it is asynchronous functions , it get hands over to browser where it stays there for the time(in ms) given in the function
// then for this period (5 sec) other statements will execute and when the time completes the setTimeOut method goes to eventqueue and then pulled over to call stack whetre it execute and 
// when execution finished it pulled off from call stack.

// http://latentflip.com/loupe/?code=CmNvbnNvbGUubG9nKCJIaSEiKTsKCnNldFRpbWVvdXQoZnVuY3Rpb24gdGltZW91dCgpIHsKICAgIGNvbnNvbGUubG9nKCJDbGljayB0aGUgYnV0dG9uISIpOwp9LCA1MDAwKTsKCmNvbnNvbGUubG9nKCJXZWxjb21lIHRvIGxvdXBlLiIpOw%3D%3D!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D
*/












